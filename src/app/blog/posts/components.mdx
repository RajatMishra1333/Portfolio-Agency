---
title: "Building a Real-Time Location Engine: Mini Life360"
publishedAt: "2025-11-25"
summary: "How I engineered a scalable location-sharing service using MERN stack, Socket.io, and Google Maps API to keep families connected."
tag: "Engineering"
---

Building a real-time location sharing application requires more than just plotting points on a map. It involves handling continuous data streams, managing device battery efficiency, and ensuring secure room-based communication.

## System Status & Alerts

For a safety application, user feedback is critical. I utilized a status component to provide immediate visual confirmation when a user successfully joins a tracking circle or if the connection drops.

<Column fillWidth gap="-1" marginBottom="16" marginTop="8">
<CodeBlock
    radius="none"
    topRadius="l"
    codeHeight={24}
    preview={<Feedback icon title="Secure Connection Established" variant="success" description="You are now sharing location data with Circle ID: #8821." marginBottom="24"/>}
    codes={[
      {
        code:
`<Feedback
    icon
    variant="success"
    title="Secure Connection Established"
    description="You are now sharing location data with Circle ID: #8821."
/>`,
        language: "tsx",
        label: "StatusAlert.tsx"
      }
    ]}
/>
<Row fillWidth bottomRadius="l" padding="4" border="neutral-medium" background="surface">
    <Button href="" weight="default" label="View Component" size="s" variant="tertiary" suffixIcon="chevronRight"/>
</Row>
</Column>

## Device Management

To manage multiple family members, I designed a schema that tracks not just location, but device health. This table demonstrates how the dashboard renders active users in a circle.

<Column fillWidth gap="-1" marginBottom="16" marginTop="8">
<CodeBlock
    radius="none"
    topRadius="l"
    preview={
    <Table 
      data={{
        headers: [
          { content: "Member", key: "member", sortable: true },
          { content: "Battery", key: "battery", sortable: true },
          { content: "Last Seen", key: "lastSeen" }
        ],
        rows: [
          ["Rajat", "82%", "Just now"],
          ["Admin", "45%", "2 min ago"],
          ["Guest Device", "15%", "Offline"]
        ]
      }}
    />}
    codes={[
      {
        code:
`<Table 
  data={{
    headers: [
      { content: "Member", key: "member", sortable: true },
      { content: "Battery", key: "battery", sortable: true },
      { content: "Last Seen", key: "lastSeen" }
    ],
    rows: [
      ["Rajat", "82%", "Just now"],
      ["Admin", "45%", "2 min ago"],
      ["Guest Device", "15%", "Offline"]
    ]
  }}
/>`,
        language: "tsx",
        label: "MembersTable.tsx"
      }
    ]}
/>
</Column>

## Socket.io Architecture

The core of the application relies on **WebSockets** for bi-directional communication. Unlike standard REST APIs which I used in my [Food Ordering Project](/blog/posts/food-ordering), this requires a persistent connection.

### Server-Side Implementation

The following snippet shows how I handle room-based emission to ensure privacyâ€”users only receive updates from their specific circle.

<Column fillWidth gap="-1" marginBottom="16" marginTop="8">
<CodeBlock
    radius="none"
    topRadius="l"
    codes={[
      {
        code:
`io.on("connection", (socket) => {
  // Join a specific family circle
  socket.on("join-circle", (circleId) => {
    socket.join(circleId);
    console.log(\`User joined circle: \${circleId}\`);
  });

  // Broadcast location only to that circle
  socket.on("send-location", ({ circleId, lat, lng }) => {
    io.to(circleId).emit("receive-location", { 
      id: socket.id, 
      lat, 
      lng 
    });
  });
});`,
        language: "javascript",
        label: "server/socket.js"
      }
    ]}
/>
</Column>

## Map Integration

I integrated the Google Maps API to visualize the coordinate data. The Media component below represents the visual output of the tracking interface.

<Column fillWidth gap="-1" marginBottom="16" marginTop="8">
<CodeBlock
    radius="none"
    topRadius="l"
    codeHeight={24}
    preview={<Media src="/images/projects/map-interface.jpg" alt="Live Map View" aspectRatio="16/9" radius="l" />}
    codes={[
      {
        code:
`<Media
    src="/images/projects/map-interface.jpg"
    alt="Live Map View"
    aspectRatio="16/9"
    radius="l"
/>`,
        language: "tsx",
        label: "MapVisualization.tsx"
      }
    ]}
/>
</Column>

## Feature Grid

Using the Grid layout, here is a quick overview of the technical capabilities I engineered into the backend.

<Column fillWidth gap="-1" marginBottom="16" marginTop="8">
<CodeBlock
    radius="none"
    topRadius="l"
    preview={
    <Grid
      fillWidth
      columns="2"
      gap="16"
    >
      <Column border="neutral-alpha-medium" padding="16" radius="m">
        <Text>Geofencing Alerts</Text>
      </Column>
      <Column border="neutral-alpha-medium" padding="16" radius="m">
        <Text>JWT Authentication</Text>
      </Column>
      <Column border="neutral-alpha-medium" padding="16" radius="m">
        <Text>Encrypted Data</Text>
      </Column>
      <Column border="neutral-alpha-medium" padding="16" radius="m">
        <Text>Battery Optimization</Text>
      </Column>
    </Grid>}
    codeHeight={24}
    codes={[
      {
        code:
`<Grid
    fillWidth
    columns="2"
    gap="16"
  >
    <Column border="neutral-alpha-medium" padding="16" radius="m">
      <Text>Geofencing Alerts</Text>
    </Column>
    <Column border="neutral-alpha-medium" padding="16" radius="m">
      <Text>JWT Authentication</Text>
    </Column>
</Grid>`,
        language: "tsx",
        label: "Features.tsx"
      }
    ]}
/>
</Column>